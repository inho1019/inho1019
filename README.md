
<br/>
<img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&size=24&pause=1000&color=36BCF7&width=435&lines=Frontend+engineer+inho_m" alt="Typing SVG" />

## Tech
<br>
<div align="center">
  <br/>
  <div>
    <img src="https://img.shields.io/badge/React-61DAFB?style=flat&logo=react&logoColor=white"/>
    <img src="https://img.shields.io/badge/ReactNative-61DAFB?style=flat&logo=react&logoColor=white"/>
    <img src="https://shields.io/badge/TypeScript-3178C6?logo=TypeScript&logoColor=FFF&style=flat-square"/>
    <img src="https://img.shields.io/badge/Graphql-E10098?style=flat&logo=graphql&logoColor=white"/>
  </div>
  <br/>
  <br/>
  <div style="display: flex; align-items: flex-start;">
    <img src="https://techstack-generator.vercel.app/github-icon.svg" alt="icon" width="70" height="70" />
    <img src="https://techstack-generator.vercel.app/react-icon.svg" alt="icon" width="70" height="70" />
    <img src="https://techstack-generator.vercel.app/ts-icon.svg" alt="icon" width="70" height="70" />
    <img src="https://techstack-generator.vercel.app/graphql-icon.svg" alt="icon" width="70" height="70" />
  </div>
</div>

## GitHub

<br>
<div align="center">
  <img src="https://streak-stats.demolab.com?user=inho1019&theme=dark&border_radius=4.5&date_format=%5BY.%5Dn.j&card_width=450&card_height=215" alt="GitHub Streak" />&nbsp;
  <img src="https://github-readme-stats.vercel.app/api/top-langs/?username=inho1019&layout=donut&theme=dark" />
</div>

<br>

## Blog
<details open>
  <summary>목록</summary>
  <ul>

<li>
    <a href="https://inho-m.tistory.com/18">FE Trend 개발기 #8 - AI 요약 기능 추가 (고도화)</a>
</li><li>
    <a href="https://inho-m.tistory.com/17">FE Trend 개발기 #7 - 코드 에디터 추가 및 개선(고도화)</a>
</li><li>
    <a href="https://inho-m.tistory.com/16">정적 페이지 데이터 압축으로 트래픽 줄이기 (feat. fflate)</a>
</li><li>
    <a href="https://inho-m.tistory.com/14">FE Trend 개발기 #6 - 웹 3차(마지막)</a>
</li><li>
    <a href="https://inho-m.tistory.com/13">FE Trend 개발기 #5 - 웹 2차</a>
</li>
  </ul>
  <a href="https://inho-m.tistory.com">전체글보기</a>
</details>

### Recent Post

<details>
<summary>FE Trend 개발기 #8 - AI 요약 기능 추가 (고도화)</summary>
<br/>
<p data-ke-size="size16">프로젝트 실사용을 하던중 ai 관련 기능 고민중 원하는 글에 대한 ai 요약 기능을 사용하면 참 좋겠다는 생각이 들어 구현을 해보았다.</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h3 data-ke-size="size23">Gemini api 를 사용한 ai 기능 사용하기</h3>
<p data-ke-size="size16">여러 ai api 에서 고민하던중 Gemini api 를 선택했다.</p>
<p data-ke-size="size16">Gemini api는 가장 가벼운 모델인 <span style="background-color: #ffffff; color: #202124; text-align: left;">gemini-2</span><span style="background-color: #ffffff; color: #202124; text-align: left;">.</span><span style="background-color: #ffffff; color: #202124; text-align: left;">5-flash-lite 모델을 사용시 하루에 1000건까지 무료로 사용이 가능하다.</span></p>
<p data-ke-size="size16"><span style="background-color: #ffffff; color: #ee2323; text-align: left;">다만 무료사용시 정보수집에 자동적으로 동의하게 되므로 민감한 개인정보 및 회사 프로젝트, 기타 보안상 문제있는 작업은 하지 않는것이 좋다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #ffffff; color: #000000; text-align: left;">사용법은 진짜 간단하다.</span></p>
<p data-ke-size="size16"><span style="background-color: #ffffff; color: #000000; text-align: left;"><a href="https://ai.google.dev/gemini-api/docs?hl=ko" target="_blank" rel="noopener&nbsp;noreferrer">https://ai.google.dev/gemini-api/docs?hl=ko</a></span></p>
<figure id="og_1755427432246" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="Gemini API &nbsp;|&nbsp; Google AI for Developers" data-og-description="Gemini Developer API 문서 및 API 참조" data-og-host="ai.google.dev" data-og-source-url="https://ai.google.dev/gemini-api/docs?hl=ko" data-og-url="https://ai.google.dev/gemini-api/docs?hl=ko" data-og-image="https://scrap.kakaocdn.net/dn/bzU7rA/hyZzKpcLtG/sPEXCfuMP8w6wM7Nm3YKB0/img.png?width=1200&amp;height=675&amp;face=0_0_1200_675,https://scrap.kakaocdn.net/dn/ejcBd2/hyZygCduI0/kkUcQvxNRW0PgBnI8e7tjK/img.png?width=774&amp;height=406&amp;face=0_0_774_406,https://scrap.kakaocdn.net/dn/cKifaV/hyZylcrSU3/SGkjBSNm0qKtq4ApRlpq51/img.png?width=774&amp;height=406&amp;face=0_0_774_406"><a href="https://ai.google.dev/gemini-api/docs?hl=ko" target="_blank" rel="noopener" data-source-url="https://ai.google.dev/gemini-api/docs?hl=ko">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/bzU7rA/hyZzKpcLtG/sPEXCfuMP8w6wM7Nm3YKB0/img.png?width=1200&amp;height=675&amp;face=0_0_1200_675,https://scrap.kakaocdn.net/dn/ejcBd2/hyZygCduI0/kkUcQvxNRW0PgBnI8e7tjK/img.png?width=774&amp;height=406&amp;face=0_0_774_406,https://scrap.kakaocdn.net/dn/cKifaV/hyZylcrSU3/SGkjBSNm0qKtq4ApRlpq51/img.png?width=774&amp;height=406&amp;face=0_0_774_406');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">Gemini API &nbsp;|&nbsp; Google AI for Developers</p>
<p class="og-desc" data-ke-size="size16">Gemini Developer API 문서 및 API 참조</p>
<p class="og-host" data-ke-size="size16">ai.google.dev</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">간단히 패키지 설치, 모델 설정, 질문할 프롬포트를 설정하면 response로 결과를 반환해준다.</p>
<pre id="code_1755427087033" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>import { GoogleGenAI } from "@google/genai";

const ai = new GoogleGenAI({ 본인의 API키 });

async function main() {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash-lite",
    contents: "Explain how AI works in a few words",
  });
  console.log(response.text);
}

await main();</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">하지만 해당 방법을 웹상에서 그대로 사용하는것은 상당히 문제가 있다.</p>
<p data-ke-size="size16">바로 요청시 api 키가 그대로 노출이 되어버리기 때문에 보안 및 악용의 우려가 있다.</p>
<p data-ke-size="size16">나는 해당 작업을 cloudflare의 worker기능을 사용하여 우회하고 CORS설정을 하여 허용할 사이트를 설정해주었다.</p>
<pre id="code_1755427808710" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>// worker.js
export default {
  async fetch(request, env) {
    const allowedOrigin = "https://fe-trend.netlify.app"; // 허용할 도메인
    const origin = request.headers.get("Origin");

    if (request.method === "OPTIONS") {
      // Preflight 요청에 대한 응답
      return new Response(null, {
        status: 204,
        headers: {
          "Access-Control-Allow-Origin": origin === allowedOrigin ? allowedOrigin : "null",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization",
          "Access-Control-Max-Age": "86400",
        },
      });
    }

    if (origin !== allowedOrigin) {
      return new Response("CORS 정책에 의해 차단됨", { status: 403 });
    }

    if (request.method !== "POST") {
      return new Response("POST 요청만 허용됩니다", { status: 405 });
    }

    const requestJSON = await request.json();
    const requestContent = requestJSON.content.trim();
    const requestLanguage = requestJSON.language;

    if (!requestContent) {
      return new Response("request 데이터가 없습니다", { status: 405 });
    }

    // GoogleGenAI API 호출용 fetch
    const apiResponse = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-goog-api-key": env.GEMINI_API_KEY,
      },
      body: JSON.stringify({
        "contents": [
          {
            "parts": [
              {
                "text": `본문: ${requestContent}

                  - 아래 조건을 꼭 지켜서 요약해줘:
                  - 바로 dangerouslySetInnerHTML에 사용할 수 있게, 불필요한 마크다운 문법(예: \`\`\`html, \`\`\`) 없이 순수 HTML 태그만 출력할 것
                  - 요약시 ${requestLanguage} 언어로 번역할 것`
              }
            ]
          }
        ],
      }),
    });

    const responseData = await apiResponse.json();
    const responseText = responseData.candidates?.[0]?.content?.parts?.[0]?.text

    if (!responseText) {
      return new Response("response 데이터가 없습니다", { status: 405 });
    }

    return new Response(responseText, {
      status: apiResponse.status,
      headers: {
        "Content-Type": "text/plain",
        "Access-Control-Allow-Origin": allowedOrigin,
      },
    });
  }
}</code></pre>
<p data-ke-size="size16">CORS 설정을 해뒀고 body에 content와 language 값을 받아서 해당언어에 맞게 요약을 할 수 있도록 하였다.</p>
<p data-ke-size="size16"><a href="https://ai.google.dev/gemini-api/docs?hl=ko#rest" target="_blank" rel="noopener&nbsp;noreferrer">https://ai.google.dev/gemini-api/docs?hl=ko#rest</a></p>
<p data-ke-size="size16">REST API로 사용하는 방식이 있으니 잘참고하고 이경우 response형식도 특정 json형식으로 반환하기에 내가 원하는 값을 얻으려면 공식문서를 잘살펴보는게 좋을것같다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">해당 worker의 주소를 프로젝트상에서 사용하여 요약된 정보를 잘받아오는것을 확인했다.</p>
<h4 data-ke-size="size20">문제</h4>
<p data-ke-size="size16">아무래도 무료 API 이기에 하루 1000회 제한이 있다. 이렇게 트래픽 적고 사용자가 많지 않은 경우에는 문제가 되지 않지만 만약 사용자가 어느정도 확보가 되었을때는 매번 요청시 금방 요청 리워드가 바닥나는 경우가 생길것이다.</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h3 data-ke-size="size23">GitHub Rest Api</h3>
<p data-ke-size="size16">그래서 생각한것이 요약한 정보를 아카이브 형식으로 깃허브에 저장해두고 추후 확인할수 있게하는 방법이었다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">해당 방식을 위해 이전에 사용했던 Octokit대신 이번엔 워커에서 좀더 편하게 사용할수 있는 GitHub Rest Api를 사용하였다.&nbsp;&nbsp;</p>
<p data-ke-size="size16"><a href="https://docs.github.com/en/rest/repos/contents?apiVersion=2022-11-28#create-or-update-file-contents" target="_blank" rel="noopener&nbsp;noreferrer">https://docs.github.com/en/rest/repos/contents?apiVersion=2022-11-28#create-or-update-file-contents</a></p>
<figure id="og_1755429118171" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="REST API endpoints for repository contents - GitHub Docs" data-og-description="Status: 201 { &quot;content&quot;: { &quot;name&quot;: &quot;hello.txt&quot;, &quot;path&quot;: &quot;notes/hello.txt&quot;, &quot;sha&quot;: &quot;95b966ae1c166bd92f8ae7d1c313e738c731dfc3&quot;, &quot;size&quot;: 9, &quot;url&quot;: &quot;https://api.github.com/repos/octocat/Hello-World/contents/notes/hello.txt&quot;, &quot;html_url&quot;: &quot;https://github.com/oct" data-og-host="docs.github.com" data-og-source-url="https://docs.github.com/en/rest/repos/contents?apiVersion=2022-11-28#create-or-update-file-contents" data-og-url="https://docs-internal.github.com/en/rest/repos/contents?apiVersion=2022-11-28" data-og-image="https://scrap.kakaocdn.net/dn/cHJ3Y2/hyZzJcLiY0/NmkRvTXTGUlq0oTbfgMG70/img.png?width=1200&amp;height=628&amp;face=0_0_1200_628,https://scrap.kakaocdn.net/dn/xnEtP/hyZyn9cyN7/SJ6Z4PzXN4m4Xhen7vEY2k/img.png?width=1200&amp;height=628&amp;face=0_0_1200_628,https://scrap.kakaocdn.net/dn/njouV/hyZzxQVJhE/X7Ilpf9rabrqUDGWLQ8kBk/img.png?width=597&amp;height=345&amp;face=0_0_597_345"><a href="https://docs.github.com/en/rest/repos/contents?apiVersion=2022-11-28#create-or-update-file-contents" target="_blank" rel="noopener" data-source-url="https://docs.github.com/en/rest/repos/contents?apiVersion=2022-11-28#create-or-update-file-contents">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/cHJ3Y2/hyZzJcLiY0/NmkRvTXTGUlq0oTbfgMG70/img.png?width=1200&amp;height=628&amp;face=0_0_1200_628,https://scrap.kakaocdn.net/dn/xnEtP/hyZyn9cyN7/SJ6Z4PzXN4m4Xhen7vEY2k/img.png?width=1200&amp;height=628&amp;face=0_0_1200_628,https://scrap.kakaocdn.net/dn/njouV/hyZzxQVJhE/X7Ilpf9rabrqUDGWLQ8kBk/img.png?width=597&amp;height=345&amp;face=0_0_597_345');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">REST API endpoints for repository contents - GitHub Docs</p>
<p class="og-desc" data-ke-size="size16">Status: 201 { "content": { "name": "hello.txt", "path": "notes/hello.txt", "sha": "95b966ae1c166bd92f8ae7d1c313e738c731dfc3", "size": 9, "url": "https://api.github.com/repos/octocat/Hello-World/contents/notes/hello.txt", "html_url": "https://github.com/oct</p>
<p class="og-host" data-ke-size="size16">docs.github.com</p>
</div>
</a></figure>
<p data-ke-size="size16">이것또한 공식문서에 잘 설명되어있다.</p>
<p data-ke-size="size16">다만 조금 해맸던것이 rest api로 사용시 userAgent를 설정해줘야되는데 문서에 따로 표기가 안된건지 내가 못찾은건지 api가 정상동작하지 않아 곤란했으나 우여곡절끝에 해결하였다.</p>
<pre id="code_1755429361628" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>// worker.js
function base64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    // @ts-ignore
    (_, p1) =&gt; String.fromCharCode('0x' + p1)
  ));
}
...
    const fileName = `${base64EncodeUnicode(requestJSON.title)}-${requestLanguage}.json`

    const now = new Date();
    const isoString = now.toISOString();

    const data = {
        content: responseText,
        createdAt: isoString,
        language: requestLanguage
    }

    const owner = "inho1019";
    const repo = "front-end-trend";
    const path = `public/archive/${fileName}`;
    const branch = "archive";

    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`;

    const body = {
      message: "Add Archive",
      content: base64EncodeUnicode(JSON.stringify(data)),
      branch: branch,
    };

    await fetch(url, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${env.GITHUB_TOKEN}`,
        "Content-Type": "application/json",
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version" : "2022-11-28",
        "User-Agent": "CloudflareWorker" // 꼭설정해줘라!!!
      },
      body: JSON.stringify(body),
    });
  ...</code></pre>
<p data-ke-size="size16">content, language, createdAt을 body에 담고 보내줬다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">깃허브 api사용시 주의점은 모든 데이터는 base64로 변환해줘야된다.&nbsp;</p>
<p data-ke-size="size16">GPT가 한글까지 호환되는 base64인코드 함수를 짜줘서 해당 함수로 적용을 하였다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이렇게 설정하고 클라이언트 상에서도 깃허브에 해당 파일이 존재하는지 검증하고, 미존재시 ai 요약 api를 사용하는 방식의 함수를 만들어 줬다.</p>
<pre id="code_1755429707543" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>// src\shared\api\get\get-ai-summary.ts
import i18next from "i18next";
import { getContent } from "./get-content";
import { Base64 } from "js-base64";

type ArchiveData = {
    content: string;
    createdAt: string;
    language: string;
}

export const getAiSummary = async (title: string, content: string) =&gt; {
    const path = `${import.meta.env.VITE_ARCHIVE_PATH}${Base64.encode(title)}-${i18next.language.substring(0, 2)}.json`;
    let octokitResponse;
    try {
        octokitResponse = await getContent&lt;ArchiveData&gt;(path, { ref: import.meta.env.VITE_ARCHIVE_REPO });
    } catch {
        octokitResponse = null;
    }

    if (octokitResponse?.data) {
        return octokitResponse.data.content
    }
    const response = await fetch(import.meta.env.VITE_AI_API_URL, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({ title, content, language: i18next.language.substring(0, 2) }),
    });
    if (!response.ok) {
        throw new Error("Failed to fetch AI summary");
    }
    return response.text();
};</code></pre>
<p data-ke-size="size16">getContent는 Octokit을 사용한 github 파일 조회 함수이다. 다른 챕터에서 다뤘기에 따로 다루지는 않겠다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">아무튼 저런식으로 깃허브 해당 repo/branch에 해당 제목의 파일이 존재하는 검증후, 존재시 해당 파일을 가져오고 미존재시 ai 요약 api, 즉 상단 워커 api를 사용하도록 하였다.</p>
<h4 data-ke-size="size20">총코드</h4>
<pre id="code_1755429868382" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>function base64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    // @ts-ignore
    (_, p1) =&gt; String.fromCharCode('0x' + p1)
  ));
}

export default {
  async fetch(request, env) {
    const allowedOrigin = "https://fe-trend.netlify.app"; // 허용할 도메인
    const origin = request.headers.get("Origin");

    if (request.method === "OPTIONS") {
      // Preflight 요청에 대한 응답
      return new Response(null, {
        status: 204,
        headers: {
          "Access-Control-Allow-Origin": origin === allowedOrigin ? allowedOrigin : "null",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization",
          "Access-Control-Max-Age": "86400",
        },
      });
    }

    if (origin !== allowedOrigin) {
      return new Response("CORS 정책에 의해 차단됨", { status: 403 });
    }

    if (request.method !== "POST") {
      return new Response("POST 요청만 허용됩니다", { status: 405 });
    }

    const requestJSON = await request.json();
    const requestContent = requestJSON.content.trim();
    const requestLanguage = requestJSON.language;

    if (!requestContent) {
      return new Response("request 데이터가 없습니다", { status: 405 });
    }

    // GoogleGenAI API 호출용 fetch
    const apiResponse = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-goog-api-key": env.GEMINI_API_KEY,
      },
      body: JSON.stringify({
        "contents": [
          {
            "parts": [
              {
                "text": `본문: ${requestContent}

                  - 아래 조건을 꼭 지켜서 요약해줘:
                  - 바로 dangerouslySetInnerHTML에 사용할 수 있게, 불필요한 마크다운 문법(예: \`\`\`html, \`\`\`) 없이 순수 HTML 태그만 출력할 것
                  - 요약시 ${requestLanguage} 언어로 번역할 것`
              }
            ]
          }
        ],
      }),
    });

    const responseData = await apiResponse.json();
    const responseText = responseData.candidates?.[0]?.content?.parts?.[0]?.text

    if (!responseText) {
      return new Response("response 데이터가 없습니다", { status: 405 });
    }

    const fileName = `${base64EncodeUnicode(requestJSON.title)}-${requestLanguage}.json`

    const now = new Date();
    const isoString = now.toISOString();

    const data = {
        content: responseText,
        createdAt: isoString,
        language: requestLanguage
    }

    const owner = "inho1019";
    const repo = "front-end-trend";
    const path = `public/archive/${fileName}`;
    const branch = "archive";

    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`;

    const body = {
      message: "Add Archive",
      content: base64EncodeUnicode(JSON.stringify(data)),
      branch: branch,
    };

    await fetch(url, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${env.GITHUB_TOKEN}`,
        "Content-Type": "application/json",
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version" : "2022-11-28",
        "User-Agent": "CloudflareWorker"
      },
      body: JSON.stringify(body),
    });

    return new Response(responseText, {
      status: apiResponse.status,
      headers: {
        "Content-Type": "text/plain",
        "Access-Control-Allow-Origin": allowedOrigin,
      },
    });
  }
}</code></pre>
<h4 data-ke-size="size20">테스트</h4>
<p><figure class="imageblock widthContent" data-ke-mobileStyle="widthOrigin" data-filename="37.gif" data-origin-width="1279" data-origin-height="897"><span data-url="https://blog.kakaocdn.net/dn/Rb90y/btsPUTDiQaB/LJ7ohUtD1bdYlBLVeKn5q1/img.gif" data-phocus="https://blog.kakaocdn.net/dn/Rb90y/btsPUTDiQaB/LJ7ohUtD1bdYlBLVeKn5q1/img.gif"><img src="https://blog.kakaocdn.net/dn/Rb90y/btsPUTDiQaB/LJ7ohUtD1bdYlBLVeKn5q1/img.gif" srcset="https://blog.kakaocdn.net/dn/Rb90y/btsPUTDiQaB/LJ7ohUtD1bdYlBLVeKn5q1/img.gif" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="1279" height="897" data-filename="37.gif" data-origin-width="1279" data-origin-height="897"/></span></figure>
</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<p data-ke-size="size16">어쩌다보니 계속 고도화 작업만 하는중...다음에는 아카이브한 파일들 기반으로 아카이브 페이지를 만들어야겠다.</p>
</details>
